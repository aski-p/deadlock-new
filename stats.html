<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deadlock 통계 - 개선된 버전</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
        }

        h1 {
            font-size: 3em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .subtitle {
            font-size: 1.2em;
            opacity: 0.8;
            margin-bottom: 20px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(380px, 1fr));
            gap: 30px;
            margin-bottom: 40px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: transform 0.3s ease;
        }

        .stat-card:hover {
            transform: translateY(-5px);
        }

        .card-title {
            font-size: 1.5em;
            margin-bottom: 20px;
            text-align: center;
            color: #ffd700;
        }

        .ranking-list {
            list-style: none;
        }

        .ranking-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .ranking-item:last-child {
            border-bottom: none;
        }

        .rank-number {
            font-size: 1.2em;
            font-weight: bold;
            color: #ffd700;
            min-width: 30px;
        }

        .item-info {
            display: flex;
            align-items: center;
            flex: 1;
            margin-left: 15px;
        }

        .item-image {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            margin-right: 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .item-image.error {
            background: linear-gradient(45deg, #ffd700, #ff8c00);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 10px;
            font-weight: bold;
        }

        .hero-image {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-right: 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        .hero-image.error {
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            font-weight: bold;
        }

        .character-name, .item-name {
            font-size: 1.1em;
        }

        .stat-value {
            font-weight: bold;
            color: #4CAF50;
        }

        .loading {
            text-align: center;
            padding: 40px;
            font-size: 1.2em;
            opacity: 0.7;
            animation: pulse 2s infinite;
        }

        .last-update {
            text-align: center;
            margin-top: 15px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            font-size: 0.9em;
            opacity: 0.8;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .error-message {
            text-align: center;
            padding: 20px;
            color: #ff6b6b;
            background: rgba(255, 107, 107, 0.1);
            border-radius: 10px;
            border: 1px solid rgba(255, 107, 107, 0.3);
        }

        .retry-button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            margin-top: 10px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        .retry-button:hover {
            background: #45a049;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        /* 네비게이션 링크 추가 */
        .nav-links {
            text-align: center;
            margin-bottom: 20px;
        }

        .nav-links a {
            color: rgba(255, 255, 255, 0.8);
            text-decoration: none;
            margin: 0 15px;
            padding: 8px 16px;
            border-radius: 5px;
            transition: all 0.3s;
        }

        .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .nav-links a.active {
            background: rgba(255, 255, 255, 0.2);
            color: #ffd700;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="nav-links">
            <a href="/">홈</a>
            <a href="/heroes">영웅</a>
            <a href="/items">아이템</a>
            <a href="/stats" class="active">통계</a>
        </div>

        <header>
            <h1>🎮 Deadlock 통계</h1>
            <p class="subtitle">캐릭터 & 아이템 랭킹 (최근 7일)</p>
            <div id="last-update" class="last-update">
                <span>📅 마지막 업데이트: 로딩 중...</span>
            </div>
        </header>

        <div class="stats-grid">
            <div class="stat-card">
                <h2 class="card-title">🏆 최고 플레이 캐릭터</h2>
                <div id="most-played-section">
                    <div class="loading">데이터를 불러오는 중...</div>
                </div>
            </div>

            <div class="stat-card">
                <h2 class="card-title">🥇 최고 승률 캐릭터</h2>
                <div id="win-rate-section">
                    <div class="loading">데이터를 불러오는 중...</div>
                </div>
            </div>

            <div class="stat-card">
                <h2 class="card-title">⚔️ 최다 사용 아이템</h2>
                <div id="items-section">
                    <div class="loading">데이터를 불러오는 중...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        console.log('=== Deadlock 통계 개선된 버전 ===');
        
        // 캐릭터 ID별 한글 이름 매핑 (정확한 매핑)
        const heroNames = {
            1: '인페르누스',     // Infernus
            2: '세븐',          // Seven
            3: '빈딕타',        // Vindicta
            4: '레이디 가이스트', // Lady Geist
            6: '아브람스',       // Abrams
            7: '레이스',        // Wraith
            8: '맥기니스',       // McGinnis
            10: '패러독스',      // Paradox
            11: '다이나모',      // Dynamo
            12: '켈빈',         // Kelvin
            13: '헤이즈',       // Haze
            14: '홀리데이',      // Holliday
            15: '비밥',         // Bebop
            16: '칼리코',       // Calico
            17: '그레이 탈론',   // Grey Talon
            18: '모 & 크릴',    // Mo & Krill
            19: '시브',         // Shiv
            20: '아이비',       // Ivy
            21: '칼리',         // Kali
            25: '워든',         // Warden
            27: '야마토',       // Yamato
            31: '래시',         // Lash
            35: '비스커스',      // Viscous
            38: '건슬링거',      // Gunslinger
            39: '보스',         // The Boss
            47: '토카막',       // Tokamak
            48: '레커',         // Wrecker
            49: '루트거',       // Rutger
            50: '포켓',         // Pocket
            51: '썸퍼',         // Thumper
            52: '미라지',       // Mirage
            53: '패덤',         // Fathom
            54: '카덴스',       // Cadence
            56: '보머',         // Bomber
            57: '실드 가이',     // Shield Guy
            58: '바이퍼',       // Vyper
            59: '밴달',         // Vandal
            60: '싱클레어',      // Sinclair
            61: '트래퍼',       // Trapper
            62: '레이븐',       // Raven
            63: '뱀파이어박쥐',   // VampireBat
            64: '드리프터',      // Drifter
            65: '프리스트',      // Priest
            66: '프랭크',       // Frank
            67: '북웜',         // Bookworm
            68: '보호',         // Boho
            69: '도어맨',       // Doorman
            70: '스카이러너',     // Skyrunner
            71: '스완',         // Swan
            72: '펑크고트'       // Punkgoat
        };
        
        // 주요 아이템 ID별 한글 이름 (직접 매핑)
        const itemNames = {};
        const itemImages = {};
        const heroImages = {};
        
        // 로컬 스토리지 캐시
        const CACHE_KEYS = {
            HERO_STATS: 'deadlock_hero_stats',
            ITEM_STATS: 'deadlock_item_stats',
            HERO_IMAGES: 'deadlock_hero_images',
            ITEM_MAPPINGS: 'deadlock_item_mappings',
            LAST_UPDATE: 'deadlock_last_update'
        };
        
        const CACHE_DURATION = 30 * 60 * 1000; // 30분
        
        // 캐시에서 데이터 가져오기
        function getCachedData(key) {
            try {
                const cached = localStorage.getItem(key);
                if (!cached) return null;
                
                const data = JSON.parse(cached);
                const now = Date.now();
                
                if (now - data.timestamp > CACHE_DURATION) {
                    localStorage.removeItem(key);
                    return null;
                }
                
                return data.value;
            } catch (error) {
                console.error('캐시 읽기 실패:', error);
                return null;
            }
        }
        
        // 캐시에 데이터 저장
        function setCachedData(key, value) {
            try {
                const data = {
                    value: value,
                    timestamp: Date.now()
                };
                localStorage.setItem(key, JSON.stringify(data));
            } catch (error) {
                console.error('캐시 저장 실패:', error);
            }
        }
        
        // 로딩 상태 업데이트 함수
        function updateLoadingStatus(section, message) {
            const element = document.getElementById(section);
            if (element) {
                element.innerHTML = `<div class="loading">${message}</div>`;
            }
        }

        // 에러 상태 표시 함수
        function showError(section, message) {
            const element = document.getElementById(section);
            if (element) {
                element.innerHTML = `<div class="error-message">❌ ${message}</div>`;
            }
        }

        // 타임아웃이 있는 fetch 함수
        async function fetchWithTimeout(url, timeout = 10000) {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeout);
            
            try {
                const response = await fetch(url, {
                    signal: controller.signal,
                    headers: {
                        'Cache-Control': 'no-cache'
                    }
                });
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                return response;
            } catch (error) {
                clearTimeout(timeoutId);
                if (error.name === 'AbortError') {
                    throw new Error('요청 시간이 초과되었습니다');
                }
                throw error;
            }
        }

        // 캐릭터 이미지 데이터 로드
        async function loadHeroImages() {
            try {
                // 캐시에서 먼저 확인
                const cachedImages = getCachedData(CACHE_KEYS.HERO_IMAGES);
                if (cachedImages) {
                    Object.assign(heroImages, cachedImages);
                    console.log('캐릭터 이미지 캐시 로드 완료:', Object.keys(heroImages).length, '개');
                    return;
                }
                
                const response = await fetchWithTimeout('https://assets.deadlock-api.com/v2/heroes', 10000);
                const heroes = await response.json();
                
                heroes.forEach(hero => {
                    if (hero.images && hero.images.icon_image_small) {
                        heroImages[hero.id] = hero.images.icon_image_small;
                    }
                });
                
                // 캐시에 저장
                setCachedData(CACHE_KEYS.HERO_IMAGES, heroImages);
                
                console.log('캐릭터 이미지 로드 완료:', Object.keys(heroImages).length, '개');
            } catch (error) {
                console.error('캐릭터 이미지 로드 실패:', error);
                // 캐시에서 이전 데이터 사용 시도
                const cachedImages = getCachedData(CACHE_KEYS.HERO_IMAGES);
                if (cachedImages) {
                    Object.assign(heroImages, cachedImages);
                    console.log('캐릭터 이미지 캐시 사용 (이전 데이터)');
                }
            }
        }
        
        // 아이템 데이터를 먼저 로드하고 매핑 생성
        async function loadItemMappings() {
            try {
                // 캐시에서 먼저 확인
                const cachedMappings = getCachedData(CACHE_KEYS.ITEM_MAPPINGS);
                if (cachedMappings) {
                    Object.assign(itemNames, cachedMappings.names);
                    Object.assign(itemImages, cachedMappings.images);
                    console.log('아이템 매핑 캐시 로드 완료:', Object.keys(itemNames).length, '개');
                    return true;
                }
                
                const response = await fetchWithTimeout('https://assets.deadlock-api.com/v2/items', 10000);
                const items = await response.json();
                
                // 주요 아이템들에 대한 한글 매핑
                const koreanNames = {
                    // 상위 아이템들 (자주 사용되는 것들)
                    'Superior Cooldown': '상급 쿨다운 감소',
                    'Extra Regen': '추가 재생',
                    'Compress Cooldown': '압축 쿨다운',
                    'Extra Spirit': '추가 정신력',
                    'Fortitude': '불굴',
                    'Extra Stamina': '추가 스태미나',
                    'Extra Health': '추가 체력',
                    'Improved Spirit': '개선된 정신력',
                    'Quicksilver Reload': '수은 재장전',
                    'Mystic Burst': '신비 점사',
                    'Enchanter\'s Emblem': '마법사 엠블럼',
                    'Rapid Rounds': '빠른 탄환',
                    'Extra Charge': '추가 충전',
                    'Extended Magazine': '확장 탄창',
                    'Titanic Magazine': '타이타닉 탄창',
                    
                    // 기타 주요 아이템들
                    'Improved Cooldown': '개선된 쿨다운 감소',
                    'Melee Charge': '근접 돌격',
                    'Basic Magazine': '기본 탄창',
                    'Bullet Armor': '총알 방어구',
                    'Spirit Armor': '정신 방어구',
                    'Healing Rite': '치유 의식',
                    'Sprint Boots': '질주 부츠',
                    'Enduring Speed': '지속 속도',
                    'Monster Rounds': '몬스터 탄환',
                    'High-Velocity Mag': '고속 탄창',
                    'Headshot Booster': '헤드샷 부스터',
                    'Kinetic Dash': '운동 돌진',
                    'Combat Barrier': '전투 방벽',
                    'Debuff Reducer': '디버프 감소',
                    'Divine Barrier': '신성 방벽',
                    'Healing Booster': '치유 부스터',
                    'Mystic Vulnerability': '신비 취약점',
                    'Return Fire': '반격 사격',
                    'Reactive Barrier': '반응형 방벽',
                    'Restorative Shot': '회복 사격',
                    'Soul Shredder Bullets': '영혼 파쇄 탄환',
                    'Explosive Rounds': '폭발 탄환',
                    'Toxic Bullets': '독성 탄환',
                    'Slowing Bullets': '둔화 탄환',
                    'Tesla Bullets': '테슬라 탄환',
                    'Hollow Point Ward': '중공탄 방어',
                    'Burst Fire': '점사',
                    'Close Quarters': '근접 전투',
                    'Long Range': '장거리',
                    'Pristine Emblem': '완벽한 엠블럼',
                    'Vitality Booster': '생명력 부스터',
                    'Spirit Power': '정신력',
                    'Weapon Damage': '무기 데미지',
                    'Ammo Scavenger': '탄약 수집가',
                    'Bullet Lifesteal': '총알 생명력 흡수',
                    'Spirit Lifesteal': '정신 생명력 흡수',
                    'Melee Lifesteal': '근접 생명력 흡수'
                };
                
                // 모든 아이템에 대해 매핑 생성
                items.forEach(item => {
                    if (item.name && koreanNames[item.name]) {
                        itemNames[item.id] = koreanNames[item.name];
                    } else if (item.name) {
                        itemNames[item.id] = item.name;
                    } else {
                        itemNames[item.id] = item.class_name || `아이템 ${item.id}`;
                    }
                    
                    // 아이템 이미지 저장 (shop_image 우선, 없으면 image 사용)
                    if (item.shop_image) {
                        itemImages[item.id] = item.shop_image;
                    } else if (item.image) {
                        itemImages[item.id] = item.image;
                    }
                });
                
                // 캐시에 저장
                setCachedData(CACHE_KEYS.ITEM_MAPPINGS, {
                    names: itemNames,
                    images: itemImages
                });
                
                console.log('아이템 매핑 완료:', Object.keys(itemNames).length, '개');
                return true;
            } catch (error) {
                console.error('아이템 매핑 실패:', error);
                // 캐시에서 이전 데이터 사용 시도
                const cachedMappings = getCachedData(CACHE_KEYS.ITEM_MAPPINGS);
                if (cachedMappings) {
                    Object.assign(itemNames, cachedMappings.names);
                    Object.assign(itemImages, cachedMappings.images);
                    console.log('아이템 매핑 캐시 사용 (이전 데이터)');
                    return true;
                }
                return false;
            }
        }
        
        function createHeroRankingHTML(items, valueUnit = '') {
            return items.map((item, index) => `
                <div class="ranking-item">
                    <span class="rank-number">${index + 1}</span>
                    <div class="item-info">
                        <div class="hero-image ${item.image ? '' : 'error'}" ${item.image ? `style="background-image: url('${item.image}'); background-size: cover;"` : ''}>
                            ${item.image ? '' : item.name.charAt(0)}
                        </div>
                        <span class="character-name">${item.name}</span>
                    </div>
                    <span class="stat-value">${item.value}${valueUnit}</span>
                </div>
            `).join('');
        }
        
        function createItemRankingHTML(items, valueUnit = '') {
            return items.map((item, index) => `
                <div class="ranking-item">
                    <span class="rank-number">${index + 1}</span>
                    <div class="item-info">
                        <div class="item-image ${item.image ? '' : 'error'}" ${item.image ? `style="background-image: url('${item.image}'); background-size: cover;"` : ''}>
                            ${item.image ? '' : '💎'}
                        </div>
                        <span class="item-name">${item.name}</span>
                    </div>
                    <span class="stat-value">${item.value}${valueUnit}</span>
                </div>
            `).join('');
        }
        
        async function loadAndDisplayData() {
            try {
                console.log('1. 이미지 및 매핑 로드 중...');
                updateLoadingStatus('most-played-section', '캐릭터 이미지 로드 중...');
                updateLoadingStatus('win-rate-section', '아이템 데이터 로드 중...');
                updateLoadingStatus('items-section', '통계 데이터 준비 중...');
                
                const [mappingSuccess] = await Promise.all([
                    loadItemMappings(),
                    loadHeroImages()
                ]);
                
                console.log('2. API 데이터 로드 중...');
                
                // 캐시된 데이터 확인
                const cachedHeroStats = getCachedData(CACHE_KEYS.HERO_STATS);
                const cachedItemStats = getCachedData(CACHE_KEYS.ITEM_STATS);
                
                let heroStats, itemStats;
                
                if (cachedHeroStats && cachedItemStats) {
                    console.log('캐시된 통계 데이터 사용');
                    heroStats = cachedHeroStats;
                    itemStats = cachedItemStats;
                    
                    updateLoadingStatus('most-played-section', '캐시 데이터 로드 중...');
                    updateLoadingStatus('win-rate-section', '캐시 데이터 로드 중...');
                    updateLoadingStatus('items-section', '캐시 데이터 로드 중...');
                } else {
                    updateLoadingStatus('most-played-section', '플레이 통계 로드 중...');
                    updateLoadingStatus('win-rate-section', '승률 데이터 로드 중...');
                    updateLoadingStatus('items-section', '아이템 통계 로드 중...');
                    
                    // 7일 전 타임스탬프 계산
                    const sevenDaysAgo = Math.floor(Date.now() / 1000) - (7 * 24 * 60 * 60);
                    
                    const [heroResponse, itemResponse] = await Promise.all([
                        fetchWithTimeout(`https://api.deadlock-api.com/v1/analytics/hero-stats?min_unix_timestamp=${sevenDaysAgo}`, 15000),
                        fetchWithTimeout(`https://api.deadlock-api.com/v1/analytics/item-stats?min_unix_timestamp=${sevenDaysAgo}`, 15000)
                    ]);
                    
                    heroStats = await heroResponse.json();
                    itemStats = await itemResponse.json();
                    
                    // 캐시에 저장
                    setCachedData(CACHE_KEYS.HERO_STATS, heroStats);
                    setCachedData(CACHE_KEYS.ITEM_STATS, itemStats);
                }
                
                console.log('3. 데이터 처리 중...');
                
                // 캐릭터 데이터 처리
                const heroData = heroStats.map(hero => ({
                    id: hero.hero_id,
                    name: heroNames[hero.hero_id] || `캐릭터 ${hero.hero_id}`,
                    matches: hero.matches || 0,
                    winRate: hero.matches > 0 ? ((hero.wins / hero.matches) * 100).toFixed(1) : '0.0',
                    image: heroImages[hero.hero_id] || ''
                }));
                
                // 최고 플레이 캐릭터
                const mostPlayed = heroData
                    .sort((a, b) => b.matches - a.matches)
                    .slice(0, 8)
                    .map(hero => ({ 
                        name: hero.name, 
                        value: hero.matches.toLocaleString(),
                        image: hero.image
                    }));
                
                // 최고 승률 캐릭터
                const bestWinRate = heroData
                    .sort((a, b) => parseFloat(b.winRate) - parseFloat(a.winRate))
                    .slice(0, 8)
                    .map(hero => ({ 
                        name: hero.name, 
                        value: hero.winRate,
                        image: hero.image
                    }));
                
                // 아이템 데이터 처리
                const maxMatches = Math.max(...itemStats.map(item => item.matches || 0));
                const topItems = itemStats
                    .sort((a, b) => (b.matches || 0) - (a.matches || 0))
                    .slice(0, 8)
                    .map(item => ({
                        name: itemNames[item.item_id] || `아이템 ${item.item_id}`,
                        value: maxMatches > 0 ? ((item.matches / maxMatches) * 100).toFixed(1) : '0.0',
                        image: itemImages[item.item_id] || ''
                    }));
                
                console.log('4. UI 업데이트 중...');
                
                // UI 업데이트
                document.getElementById('most-played-section').innerHTML = 
                    '<ul class="ranking-list">' + createHeroRankingHTML(mostPlayed) + '</ul>';
                    
                document.getElementById('win-rate-section').innerHTML = 
                    '<ul class="ranking-list">' + createHeroRankingHTML(bestWinRate, '%') + '</ul>';
                    
                document.getElementById('items-section').innerHTML = 
                    '<ul class="ranking-list">' + createItemRankingHTML(topItems, '%') + '</ul>';
                
                // 업데이트 시간 표시
                const now = new Date();
                const updateTime = now.toLocaleString('ko-KR', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    timeZone: 'Asia/Seoul'
                });
                
                document.getElementById('last-update').innerHTML = 
                    `<span>📅 마지막 업데이트: ${updateTime} (KST)</span>`;
                
                console.log('✅ 모든 데이터 로딩 완료!');
                
            } catch (error) {
                console.error('❌ 데이터 로딩 실패:', error);
                
                // 캐시된 데이터로 폴백 시도
                const cachedHeroStats = getCachedData(CACHE_KEYS.HERO_STATS);
                const cachedItemStats = getCachedData(CACHE_KEYS.ITEM_STATS);
                
                if (cachedHeroStats && cachedItemStats) {
                    console.log('🔄 캐시된 데이터로 폴백');
                    
                    try {
                        // 캐시된 데이터로 UI 업데이트 시도
                        const heroData = cachedHeroStats.map(hero => ({
                            id: hero.hero_id,
                            name: heroNames[hero.hero_id] || `캐릭터 ${hero.hero_id}`,
                            matches: hero.matches || 0,
                            winRate: hero.matches > 0 ? ((hero.wins / hero.matches) * 100).toFixed(1) : '0.0',
                            image: heroImages[hero.hero_id] || ''
                        }));
                        
                        const mostPlayed = heroData
                            .sort((a, b) => b.matches - a.matches)
                            .slice(0, 8)
                            .map(hero => ({ 
                                name: hero.name, 
                                value: hero.matches.toLocaleString(),
                                image: hero.image
                            }));
                        
                        const bestWinRate = heroData
                            .sort((a, b) => parseFloat(b.winRate) - parseFloat(a.winRate))
                            .slice(0, 8)
                            .map(hero => ({ 
                                name: hero.name, 
                                value: hero.winRate,
                                image: hero.image
                            }));
                        
                        const maxMatches = Math.max(...cachedItemStats.map(item => item.matches || 0));
                        const topItems = cachedItemStats
                            .sort((a, b) => (b.matches || 0) - (a.matches || 0))
                            .slice(0, 8)
                            .map(item => ({
                                name: itemNames[item.item_id] || `아이템 ${item.item_id}`,
                                value: maxMatches > 0 ? ((item.matches / maxMatches) * 100).toFixed(1) : '0.0',
                                image: itemImages[item.item_id] || ''
                            }));
                        
                        document.getElementById('most-played-section').innerHTML = 
                            '<ul class="ranking-list">' + createHeroRankingHTML(mostPlayed) + '</ul>';
                            
                        document.getElementById('win-rate-section').innerHTML = 
                            '<ul class="ranking-list">' + createHeroRankingHTML(bestWinRate, '%') + '</ul>';
                            
                        document.getElementById('items-section').innerHTML = 
                            '<ul class="ranking-list">' + createItemRankingHTML(topItems, '%') + '</ul>';
                        
                        document.getElementById('last-update').innerHTML = 
                            `<span>⚠️ 네트워크 오류 - 캐시된 데이터 표시 중</span>`;
                        
                        return; // 캐시 데이터로 성공적으로 표시했으므로 여기서 종료
                    } catch (cacheError) {
                        console.error('캐시 데이터 처리 실패:', cacheError);
                    }
                }
                
                // 캐시도 실패한 경우 에러 메시지 표시
                showError('most-played-section', `데이터 로드 실패: ${error.message}`);
                showError('win-rate-section', `데이터 로드 실패: ${error.message}`);
                showError('items-section', `데이터 로드 실패: ${error.message}`);
                
                document.getElementById('last-update').innerHTML = 
                    `<span>❌ 업데이트 실패: ${error.message}</span>`;
                
                // 재시도 버튼 추가
                setTimeout(() => {
                    document.getElementById('last-update').innerHTML += 
                        '<br><button onclick="loadAndDisplayData()" class="retry-button">🔄 다시 시도</button>';
                }, 1000);
            }
        }
        
        // 페이지 로드 시 실행
        window.addEventListener('load', loadAndDisplayData);
    </script>
</body>
</html>